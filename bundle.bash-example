if [ "${BASH_SOURCE-}" = "$0" ]; then
    echo "You must source this script: \$ source $0" >&2
    exit 33
fi

bundle-exit () {
    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi
}

# reset bundle enveronments
bundle-exit

############################################################

source .env

DOCKER_COMPOSE="sudo /usr/bin/docker compose -p ${PROJECT_NAME}"
DOCKER_COMPOSE_CRON="${DOCKER_COMPOSE} -f ${USERSIDE_BASE_DIR}/compose.yaml --env-file ${USERSIDE_BASE_DIR}/.env"

# Change prompt
_OLD_VIRTUAL_PS1="${PS1-}"
if [ "x" != x ] ; then
    PS1="${PS1-}"
else
    PS1="${PROJECT_NAME} ${PS1-}"
fi
export PS1

## CRON
# If you need edit base cron file, do it here!
userside-cron-create () {
    sudo tee /etc/cron.d/${PROJECT_NAME} > /dev/null <<EOT
# DO NOT EDIT THIS FILE !!!
* * * * *    root    ${DOCKER_COMPOSE_CRON} run --rm php php userside cron > /dev/null
0 3 * * *    root    ${DOCKER_COMPOSE_CRON} run --rm php /app/backup.sh > /dev/null
0 4 * * *    root    ${DOCKER_COMPOSE_CRON} exec postgres /app/backup.sh > /dev/null
#*/10 * * * *   root    ${DOCKER_COMPOSE_CRON} run --rm usm_billing > /dev/null
EOT
}
alias userside-cron-remove="sudo rm -f /etc/cron.d/${PROJECT_NAME}"
alias userside-cron-run="${DOCKER_COMPOSE} run --rm php php userside cron"

## POSTGRESQL
alias bundle-pgsql="${DOCKER_COMPOSE} exec postgres psql -U ${POSTGRES_USER} -d ${POSTGRES_DB}"
alias bundle-pg-postgis-update="${DOCKER_COMPOSE} exec postgres /usr/local/bin/update-postgis.sh"

## RABBITMQ
alias bundle-rabbitctl="${DOCKER_COMPOSE} exec rabbitmq rabbitmqctl $1"
rabbitmq-create-stomp-user () {
    read -p "WebSocket username: " -r STOMP_USER
    read -p "WebSocket password: " -s -r STOMP_PASSWORD
    bundle-rabbitctl add_user "${STOMP_USER}" "${STOMP_PASSWORD}"
    bundle-rabbitctl set_permissions -p "/" "${STOMP_USER}" "^userside-stomp:id-.*" "" "^userside-stomp:id-.*"
    echo
    echo "Done"
}
alias bundle-rabbit-stop="bundle-rabbitctl stop_app"
alias bundle-rabbit-reset="bundle-rabbitctl reset"
alias bundle-rabbit-start="bundle-rabbitctl start_app"
alias rabbitmq-cleanup="bundle-rabbit-stop ; bundle-rabbit-reset ; bundle-rabbit-start"

## INSTALLER
alias userside-install="${DOCKER_COMPOSE} run --rm php /app/userside_install.sh install"
alias userside-repair="${DOCKER_COMPOSE} run --rm php /app/userside_install.sh repair"
alias userside-stability="${DOCKER_COMPOSE} run --rm php /app/userside_install.sh config --stability=$1"

## USERSIDE COMMANDS
alias userside-flush-cache="${DOCKER_COMPOSE} run --rm php php userside cache/flush-all"

## DOCKER SERVICE COMMANDS
awaiting_postgres_tobe_ready() {
  echo -n "Awaiting for the PostgreSQL."
  until echo -n "." ; ${DOCKER_COMPOSE} exec -T postgres pg_isready -U ${POSTGRES_USER} --timeout=0 -d ${POSTGRES_DB} -q > /dev/null 2>&1; do sleep 1; done
  echo "ready!"
  sleep 1
}

awaiting_rabbitmq_tobe_ready() {
  echo -n "Awaiting for the RabbitMQ."
  until echo -n "." ; curl -f http://172.31.254.1:15672 > /dev/null 2>&1; do sleep 1; done
  echo "ready!"
  sleep 1
}

#########
## BUNDLE
bundle-start () {
    ${DOCKER_COMPOSE} up -d --scale core-worker=${CORE_WORKER_NUM} --scale poller=${POLLER_NUM}
    userside-cron-create
    awaiting_postgres_tobe_ready
    awaiting_rabbitmq_tobe_ready
}
bundle-stop () {
    userside-cron-remove
    ${DOCKER_COMPOSE} stop
}
alias bundle-restart="bundle-stop && bundle-start"
alias bundle-logs="${DOCKER_COMPOSE} logs -f $1"
alias bundle-pull="${DOCKER_COMPOSE} pull"

bundle-install () {
    fail() { : "${__fail_fast:?$1}"; }
    sudo mkdir -p ${USERSIDE_BASE_DIR}/data/db ${USERSIDE_BASE_DIR}/data/backup ${USERSIDE_BASE_DIR}/data/userside
    sudo mkdir -p ${USERSIDE_BASE_DIR}/data/userside/var/log/usm_billing

    test -f ${USERSIDE_BASE_DIR}/data/userside/.env || echo "" | sudo tee ${USERSIDE_BASE_DIR}/data/userside/.env > /dev/null

    if [[ ! -f ${USERSIDE_BASE_DIR}/data/userside/installer.json ]]; then
        sudo tee ${USERSIDE_BASE_DIR}/data/userside/installer.json > /dev/null <<EOT
{
  "pgsql_dsn": "pgsql:host=postgres;dbname=${POSTGRES_DB};port=5432;username=${POSTGRES_USER};password=${POSTGRES_PASSWORD}",
  "redis_url": "redis://${REDIS_PASSWORD}@redis",
  "rabbit_url": "amqp://${RABBITMQ_DEFAULT_USER}:${RABBITMQ_DEFAULT_PASS}@rabbitmq:5672/%2f",
  "stability": "stable"
}
EOT
    fi

    bundle-start || fail "Error"
    userside-install || fail "Error"
    userside-cron-create || fail "Error"
    userside-cron-run || fail "Error"
    rabbitmq-cleanup || fail "Error"
    bundle-restart || fail "Error"
}

bundle-update () {
    fail() { : "${__fail_fast:?$1}"; }
    backup-make || fail "Error"
    userside-flush-cache || fail "Error"
    bundle-stop || fail "Error"
    bundle-pull || fail "Error"
    userside-cron-remove || fail "Error"
    bundle-install || fail "Error"
}

bundle-destroy () {
    read -p "This action will DELETE all data of ${PROJECT_NAME}! Are you sure? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        ${DOCKER_COMPOSE} down -v --remove-orphans
    fi
}

alias bundle-purge="bundle-destroy && sudo rm --rf ${USERSIDE_BASE_DIR}/data/userside ${USERSIDE_BASE_DIR}/data/db"

#################
## BACKUP RESTORE
backup-make () {
    ${DOCKER_COMPOSE} exec postgres /app/backup.sh
	${DOCKER_COMPOSE} run --rm php /app/backup.sh
}

backup-restore-db () {
    read -p "Dump file name: " -r DUMP
    echo
    ${DOCKER_COMPOSE} exec postgres /app/restore.sh ${DUMP}
}
